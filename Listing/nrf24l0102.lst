C51 COMPILER V9.00   NRF24L0102                                                            09/11/2016 18:20:08 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE NRF24L0102
OBJECT MODULE PLACED IN .\Output\nrf24l0102.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE Common\src\nrf24l0102.c LARGE BROWSE INCDIR(.\Common\inc;.\Driver\inc;.\BSP
                    -;.\Startup;.\User) DEBUG OBJECTEXTEND PRINT(.\Listing\nrf24l0102.lst) OBJECT(.\Output\nrf24l0102.obj)

line level    source

   1          #include "IAP15W4K61S4.h"
   2          #include <intrins.h>
   3          #include <NRF24L0102.H>
   4          #include "led.h"
   5          #include "delay.h"
   6          
   7          unsigned char TxBuf[20]={0};
   8          unsigned char RxBuf[20]={0}; // Ω” ’µƒ ˝æ›  ˝◊È
   9          //*********************************************NRF24L01*************************************
  10          #define TX_ADR_WIDTH    5       // 5 uints TX address width
  11          #define RX_ADR_WIDTH    5       // 5 uints RX address width
  12          #define TX_PLOAD_WIDTH  20      // 20 uints TX payload
  13          #define RX_PLOAD_WIDTH  20      // 20 uints TX payload
  14          uint const TX_ADDRESS[TX_ADR_WIDTH]= {0x34,0x43,0x10,0x10,0x01};        //±æµÿµÿ÷∑
  15          uint const RX_ADDRESS[RX_ADR_WIDTH]= {0x34,0x43,0x10,0x10,0x01};        //Ω” ’µÿ÷∑
  16          
  17          //*****************************************≥§—” ±*****************************************
  18          void Delay(unsigned int s)
  19          {
  20   1              unsigned int i;
  21   1              for(i=0; i<s; i++);
  22   1              for(i=0; i<s; i++);
  23   1      }
  24          //******************************************************************************************
  25          uint    bdata sta;   //◊¥Ã¨±Í÷æ
  26          sbit    RX_DR   =sta^6;
  27          sbit    TX_DS   =sta^5;
  28          sbit    MAX_RT  =sta^4;
  29          sbit  TX_FULL =sta^0;
  30          /******************************************************************************************
  31          /*—” ±∫Ø ˝
  32          /******************************************************************************************/
  33          void inerDelay_us(unsigned char n)
  34          {
  35   1              for(;n>0;n--);
  36   1              _nop_();
  37   1      
  38   1      }
  39          //****************************************************************************************
  40          /*NRF24L01≥ı ºªØ
  41          //***************************************************************************************/
  42          void init_NRF24L01(void)
  43          {
  44   1              CE=0;    // chip enable
  45   1              CSN=1;   // Spi  disable 
  46   1              SCK=0;   // 
  47   1              SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);    // –¥±æµÿµÿ÷∑  
  48   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, RX_ADDRESS, RX_ADR_WIDTH); // –¥Ω” ’∂Àµÿ÷∑
  49   1              SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);      //  ∆µµ¿0◊‘∂Ø ACK”¶¥‘ –Ì     
  50   1              SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);  //  ‘ –ÌΩ” ’µÿ÷∑÷ª”–∆µµ¿0£¨»Áπ˚–Ë“™∂‡∆µµ¿ø…“‘≤ŒøºPage21  
  51   1              //SPI_RW_Reg(WRITE_REG + EN_AA, 0x00);           // ßƒ‹Õ®µ¿0◊‘∂Ø”¶¥
  52   1          //SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);    //Ω” ’“™ πƒ‹Ω” ’Õ®µ¿0
  53   1      
  54   1              SPI_RW_Reg(WRITE_REG + RF_CH, 0);        //   …Ë÷√–≈µ¿π§◊˜Œ™2.4GHZ£¨ ’∑¢±ÿ–Î“ª÷¬
C51 COMPILER V9.00   NRF24L0102                                                            09/11/2016 18:20:08 PAGE 2   

  55   1              SPI_RW_Reg(WRITE_REG + RX_PW_P0, RX_PLOAD_WIDTH); //…Ë÷√Ω” ’ ˝æ›≥§∂»£¨±æ¥Œ…Ë÷√Œ™32◊÷Ω⁄
  56   1              SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);                 //…Ë÷√∑¢…‰ÀŸ¬ Œ™1MB/S£¨∑¢…‰π¶¬ Œ™◊Ó¥Û÷µ+7dB£¨”…”⁄”–X2401Lπ¶∑≈
             -£¨ µº +21dbm ‰≥ˆ
  57   1      }
  58          /****************************************************************************************************
  59          /*∫Ø ˝£∫uint SPI_RW(uint uchar)
  60          /*π¶ƒ‹£∫NRF24L01µƒSPI–¥ ±–Ú
  61          /****************************************************************************************************/
  62          uint SPI_RW(uint uchar)
  63          {
  64   1              uint bit_ctr;
  65   1              for(bit_ctr=0;bit_ctr<8;bit_ctr++) // output 8-bit
  66   1              {
  67   2                      MOSI = (uchar & 0x80);         // output 'uchar', MSB to MOSI
  68   2                      uchar = (uchar << 1);           // shift next bit into MSB..
  69   2                      SCK = 1;                      // Set SCK high..
  70   2                      inerDelay_us(12);
  71   2                      uchar |= MISO;                    // capture current MISO bit
  72   2                      inerDelay_us(12);
  73   2                      SCK = 0;                          // ..then set SCK low again
  74   2              }
  75   1          return(uchar);                        // return read uchar
  76   1      }
  77          /****************************************************************************************************
  78          /*∫Ø ˝£∫uchar SPI_Read(uchar reg)
  79          /*π¶ƒ‹£∫NRF24L01µƒSPI ±–Ú
  80          /****************************************************************************************************/
  81          uchar SPI_Read(uchar reg)
  82          {
  83   1              uchar reg_val;
  84   1              
  85   1              CSN = 0;                // CSN low, initialize SPI communication...
  86   1              inerDelay_us(12);
  87   1              SPI_RW(reg);            // Select register to read from..
  88   1              inerDelay_us(12);
  89   1              reg_val = SPI_RW(0);    // ..then read registervalue
  90   1              inerDelay_us(12);
  91   1              CSN = 1;                // CSN high, terminate SPI communication
  92   1              
  93   1              return(reg_val);        // return register value
  94   1      }
  95          /****************************************************************************************************/
  96          /*π¶ƒ‹£∫NRF24L01∂¡–¥ºƒ¥Ê∆˜∫Ø ˝
  97          /****************************************************************************************************/
  98          uint SPI_RW_Reg(uchar reg, uchar value)
  99          {
 100   1              uint status;
 101   1              
 102   1              CSN = 0;                   // CSN low, init SPI transaction
 103   1              status = SPI_RW(reg);      // select register
 104   1              SPI_RW(value);             // ..and write value to it..
 105   1              CSN = 1;                   // CSN high again
 106   1              
 107   1              return(status);            // return nRF24L01 status uchar
 108   1      }
 109          /****************************************************************************************************/
 110          /*∫Ø ˝£∫uint SPI_Read_Buf(uchar reg, uchar *pBuf, uchar uchars)
 111          /*π¶ƒ‹: ”√”⁄∂¡ ˝æ›£¨reg£∫Œ™ºƒ¥Ê∆˜µÿ÷∑£¨pBuf£∫Œ™¥˝∂¡≥ˆ ˝æ›µÿ÷∑£¨uchars£∫∂¡≥ˆ ˝æ›µƒ∏ˆ ˝
 112          /****************************************************************************************************/
 113          uint SPI_Read_Buf(uchar reg, uchar *pBuf, uchar uchars)
 114          {
 115   1              uint status,uchar_ctr;
C51 COMPILER V9.00   NRF24L0102                                                            09/11/2016 18:20:08 PAGE 3   

 116   1              
 117   1              CSN = 0;                                // Set CSN low, init SPI tranaction
 118   1              status = SPI_RW(reg);                   // Select register to write to and read status uchar
 119   1              
 120   1              for(uchar_ctr=0;uchar_ctr<uchars;uchar_ctr++)
 121   1                      pBuf[uchar_ctr] = SPI_RW(0);    // 
 122   1              
 123   1              CSN = 1;                           
 124   1              
 125   1              return(status);                    // return nRF24L01 status uchar
 126   1      }
 127          /*********************************************************************************************************
 128          /*∫Ø ˝£∫uint SPI_Write_Buf(uchar reg, uchar *pBuf, uchar uchars)
 129          /*π¶ƒ‹: ”√”⁄–¥ ˝æ›£∫Œ™ºƒ¥Ê∆˜µÿ÷∑£¨pBuf£∫Œ™¥˝–¥»Î ˝æ›µÿ÷∑£¨uchars£∫–¥»Î ˝æ›µƒ∏ˆ ˝
 130          /*********************************************************************************************************
             -/
 131          uint SPI_Write_Buf(uchar reg, uchar *pBuf, uchar uchars)
 132          {
 133   1              uint status,uchar_ctr;
 134   1              
 135   1              CSN = 0;            //SPI πƒ‹       
 136   1              status = SPI_RW(reg);   
 137   1              for(uchar_ctr=0; uchar_ctr<uchars; uchar_ctr++) //
 138   1              SPI_RW(*pBuf++);
 139   1              CSN = 1;           //πÿ±’SPI
 140   1              return(status);    // 
 141   1      }
 142          /****************************************************************************************************/
 143          /*∫Ø ˝£∫void SetRX_Mode(void)
 144          /*π¶ƒ‹£∫ ˝æ›Ω” ’≈‰÷√ 
 145          /****************************************************************************************************/
 146          void SetRX_Mode(void)
 147          {
 148   1              CE=0;
 149   1              SPI_RW_Reg(WRITE_REG + CONFIG2, 0x0f);                  // IRQ ’∑¢ÕÍ≥…÷–∂œœÏ”¶£¨16ŒªCRC £¨÷˜Ω” ’
 150   1              CE = 1; 
 151   1      }
 152          /******************************************************************************************************/
 153          /*∫Ø ˝£∫unsigned char nRF24L01_RxPacket(unsigned char* rx_buf)
 154          /*π¶ƒ‹£∫ ˝æ›∂¡»°∫Û∑≈»Árx_bufΩ” ’ª∫≥Â«¯÷–
 155          /******************************************************************************************************/
 156          unsigned char nRF24L01_RxPacket(unsigned char* rx_buf)
 157          {
 158   1              
 159   1        unsigned char revale=0;
 160   1              //DisableInterrupts;
 161   1              sta=SPI_Read(STATUS);   // ∂¡»°◊¥Ã¨ºƒ¥Ê∆‰¿¥≈–∂œ ˝æ›Ω” ’◊¥øˆ
 162   1              if(RX_DR)                               // ≈–∂œ «∑ÒΩ” ’µΩ ˝æ›
 163   1              {
 164   2                  CE = 0;                     //SPI πƒ‹
 165   2                      SPI_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);// read receive payload from RX_FIFO buffer
 166   2                      revale =1;                      //∂¡»° ˝æ›ÕÍ≥…±Í÷æ
 167   2              }
 168   1              SPI_RW_Reg(WRITE_REG+STATUS,sta);   //Ω” ’µΩ ˝æ›∫ÛRX_DR,TX_DS,MAX_PT∂º÷√∏ﬂŒ™1£¨Õ®π˝–¥1¿¥«Â≥˛÷–∂œ±Í÷æ
 169   1                 CE=1; 
 170   1              // EnableInterrupts;                                                                      //£°£°£°£°£°£°£
             -°£°£°£°£°£°£°£°£°£°£°£°£°£°£°£°£°£°£°£°£°£°£°
 171   1              return revale;
 172   1      }
 173          /*********************************************************************************************************
             -**
 174          /*∫Ø ˝£∫void nRF24L01_TxPacket(unsigned char * tx_buf)
C51 COMPILER V9.00   NRF24L0102                                                            09/11/2016 18:20:08 PAGE 4   

 175          /*π¶ƒ‹£∫∑¢ÀÕ tx_buf÷– ˝æ›
 176          /*********************************************************************************************************
             -*/
 177          void nRF24L01_TxPacket(unsigned char * tx_buf)
 178          {
 179   1              SPI_RW_Reg(WRITE_REG+STATUS,0xff);
 180   1              SPI_RW_Reg(0xE1,0xff);
 181   1              CE=0;           
 182   1              SPI_Write_Buf(WR_TX_PLOAD, tx_buf, TX_PLOAD_WIDTH);                          
 183   1              SPI_RW_Reg(WRITE_REG + CONFIG2, 0x0e);                  
 184   1              CE=1;            
 185   1              inerDelay_us(10);   //CE∏ﬂµÁ∆Ω¥Û”⁄10us≤≈ƒ‹Ω¯»Î∑¢…‰ƒ£ Ω
 186   1      }
 187          
 188          unsigned char NRF24L01_Check(void)
 189                  {
 190   1              uchar check_in_buf[5]={0x11,0x22,0x33,0x44,0x55};
 191   1              uchar check_out_buf[5]={0x00};
 192   1              SPI_Write_Buf(WRITE_REG+TX_ADDR,check_in_buf,5);//–¥»Î5∏ˆ◊÷Ω⁄µƒµÿ÷∑.    
 193   1              SPI_Read_Buf(TX_ADDR,check_out_buf,5); //∂¡≥ˆ–¥»Îµƒµÿ÷∑  
 194   1              if((check_out_buf[0] == 0x11)&&(check_out_buf[1] == 0x22)&&(check_out_buf[2] == 0x33)&&(check_out_buf[3] 
             -== 0x44)&&(check_out_buf[4] == 0x55))
 195   1              return 0;
 196   1              else return 1;
 197   1      }                                                                  
 198                          
 199          void checkstatus()
 200          {
 201   1      unsigned char temp1,temp2;
 202   1              temp1=SPI_Read(STATUS);
 203   1                temp2=SPI_Read(FIFO_STATUS);
 204   1                if(temp1==0x40)
 205   1                      {
 206   2                              //Delaynms(100);
 207   2                              LED0=~LED0;
 208   2                              LED1=~LED1;                     
 209   2                      }       
 210   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    602    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =     50      29
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
